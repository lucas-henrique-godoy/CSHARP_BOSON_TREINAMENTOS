							* CURSO DE C# DO CANAL BÓSON TREINAMENTOS *

NAMESPACES: Usado para organizar tipos (classes), permitindo evitar colisões de nomes. Basicamente, um namespace é uma coleção nomeada de classes.

- Boa prática: todas as classes devem ser definidas dentro de um namespace.
EX.:
Classe Console (definida pelo C#)
System.Console - nome completo.

_________________________________________________________________________________________________________________________________________________________________________
Classe Console(definida pelo usuário)
Namespace MinhasClasses
MinhasClasses.Console - nome completo.

Se eu colocar a minha classe em outro Namespace e usar o nome completo como: MinhasClasses. Console não gerará conflito. Mas se eu utilizar o nome parcial como: Console, ai terá conflito e eu teria que usar apenas uma das 2 classes Console o projeto.
_______________________________________________________________________________________________________________________________________________________________________

DIRETIVA USING: Trazem os Namespaces para o escopo  do projeto. Desta forma não é necessário qualificar explicitamente os objetos com o respectivo namspace. Ou seja, inclui outros namespaces no programa.
EX: Assim posso escrever: Console.WriteLine ao invés de System.Console.WriteLine.
_______________________________________________________________________________________________________________________________________________________________________

ASSEMBLY /MONTAGEM: As classes são compiladas em Assemblies - São arquivos, usualmente com a extensão .dll. As classes mais comuns, System.Console pertencem ao assembly mscorlib.dll. Uma montagem pode conter classes definidas em muitos namespaces, e um namespace pode ocupar vários assemblies. Para usarmos as classes de um assembly, devemos adicionar uma referência no projeto, e incluir a diretiva "using" adequada.
_______________________________________________________________________________________________________________________________________________________________________

REFERÊNCIAS: Uma referência permite que utilizemos tipos disponíveis em outros Assemblies, tanto do FLC quanto de terceiros.
FCL = Framework Class Library.
_______________________________________________________________________________________________________________________________________________________________________

DECLARAÇÃO DE VARIÁVEIS:
Sintaxe : tipo variável nome variável

EXEMPLOS:
int numero01;
strignme;

ATRIBUIÇÃO DE  VALORES A UMA VARIÁVEL: nome variável = valor;

EXEMPLO:
numero1= 30;
int numer02 = 200;

POSSO DECLARAR MAIS DE UMA VARIÁVEL QUE FOREM DO MESMO TIPO NAMESMA LINHA: int x, y;
AGORA DECLANDO E ATRIBUINDO VALOR: int x = 20, y = 30;

TIPS DIFERENTES: Linhas diferentes:
int x= 20;
boola = true.
_______________________________________________________________________________________________________________________________________________________________________

OPERADORES ARITMÉTICOS: 
+ ADIÇÃO
- SUBTRAÇÃO
/ DVISÃO
* MULTIPLICAÇÃO
% MÓDULO(RESRO DA DIVISÃO INTEIRA)
_______________________________________________________________________________________________________________________________________________________________________

OBSERVAÇÕES: 

Divisão por zero é infinito.
Os tipos doble e float possuem um valor especial para representar o infinito: 5.0 / 0.0 -> +infinito.
Porém: 0.0 / 0.0 -> NaN (Not a Nuber), pois é um paradoxo - zero dividido por qualquer valor é zero, mas qualquer valor dividido por zero é infinito.
_______________________________________________________________________________________________________________________________________________________________________

PRECEDÊNCIA DOS OPERADORES: Os operadores são avaliados na seguinte ordem de precedência:

()
* / %
+ -
_______________________________________________________________________________________________________________________________________________________________________

CONVERÇÃO DE INTEIRO EM STRING: 
int numero = 123;
string numeroStr = numero.ToString(); // "123"

CONVERÇÃO DE STRING EM INTEIRO:
string valor01 = "25";
Console.WriteLine(Int32.Parse(valor01));
_______________________________________________________________________________________________________________________________________________________________________

OPERADORES DE ATRIBUIÇÃO:
=: toma um valor e coloca dentro de uma variável.

+=: acumular valores dentro de uma variável. Tomar um valor que já está na variável e somar outro valor a esse valor anterior. Ex: var += valor é equivalente a var = var + valor.

-=: subtrai um valor de uma variável. Tomar um valor que já está na variável e subtrair outro valor. Ex: var -= valor é equivalente a var = var - valor.

*=: multiplica o valor atual da variável pelo valor especificado. Ex: var *= valor é equivalente a var = var * valor.

/=: divide o valor da variável pelo valor especificado. Ex: var /= valor é equivalente a var = var / valor.

%=: calcula o resto da divisão do valor da variável pelo valor especificado. Ex: var %= valor é equivalente a var = var % valor.
_______________________________________________________________________________________________________________________________________________________________________

OPERADORES DE INCREMENTO E DECREMENTO

 Incremento e Decremento Pré-fixos: Incrementa a variável primeiro e depois executa o comando que esta asssociado a variável.
 ++variável |  variável = variável + 1 |  variável += 1
 --variável |  variável = variável - 1 |  variável -= 1

Incremento e Decremento Pós- fixos: Primeiro executa o comando associado a variável e depois incrementa a variável.
variável++   |  variável = variável + 1  |   variável += 1
variável--   |  variável = variável - 1  |   variável -= 1
_______________________________________________________________________________________________________________________________________________________________________

OPERADORES RELACIONAIS E LÓGICOS:

USANDO OPERADORES BOOLEANOS: Um operador booleano é um operador que realiza um cálculo cujo resultado pode ser ture ou false. Em C# hhá vários operadores booleanos, que podem ser classificados em dois tipos distintos:
- Operadores Relacionais e de Igualdade:
== 	Igual a        x == 15
!= 	Diferente de   a != "Laranja"
< 	Menor          c < 40			
<= 	Menor que      x <= y
> 	Maior          salario > 100
>= 	Maior que      taxa >= 400



- Operadores Condicionais Lógicos: Permitem combinar expressões ou valores booleanos e retornar um resultado lógico.
! (NOT): Inverte o valor lógico de uma expressão. Se a expressão for verdadeira, o resultado é falso, e vice-versa.
&& (AND): Avalia dois ou mais valores lógicos. O resultado é verdadeiro apenas se todos os valores forem verdadeiros.
|| (OR): Avalia dois ou mais valores lógicos. O resultado é verdadeiro se pelo menos um dos valores for verdadeiro.
_______________________________________________________________________________________________________________________________________________________________________

ESTRUTURAS DE CONTROLE CONDICIONAL SIMPLES:

CONDICIONAL IF: Usada para testar condições e determinar as ações a seguir de acordo com o resultado do teste.
Sintaxe:
if (expressão) {	
    códigos a executar;	
}


ESTRUTURAS DE CONTROLE CONDICIONAL COMPOSTO:
Sintaxe:
if (expressão) {	
    códigos a executar se expressão for verdadeira;	
}
else
{
   códigos a executar se expressão for falsa;	
}
_______________________________________________________________________________________________________________________________________________________________________

DECLARAÇÃO SWITCH ("comando caso"). Só é possível usar com alguns tipos de dados como: int, string ou char. Nos caes devem ser sempre valores constantes, não é possível calculalos, ou seja para usar os valores nos cases eles não podem ser alterados.
Sintaxe:
switch (expressão)
{
  case valor_a_ser_comparado_01:
	código a ser executado
	brake;
 case valor_a_ser_comparado_02:
	código a ser executado
	brake;
 case valor_a_ser_comparado_03:
	código a ser executado
	brake;
 default:
	código a ser executado
	break;
}


OBS: Não é possível atribuir o mesmo valro para dois rótulos case distintos. 
EX: 
case 1:
case 1:
	código a ser executado
	brake;
_______________________________________________________________________________________________________________________________________________________________________

ESTRUTURAS DE REPETIÇÃO: É um bloco de códigos que pode ser repetido indefinidamente ou  um número definido de vezes em sequência automaticamente. As vezes precisamos que determinadas instruções seja repetidas várias vezes em sequência. Elas são:   WHILE, FOR, DO.
_______________________________________________________________________________________________________________________________________________________________________
ESTRUTURA WHILE ("Enquanto"): Usamos a declaração while para rodar um bloco de códigos repetidamente enquanto uma condição de teste especificada retornar verdadeiro (valor lógico).

Sintaxe:

while (expressão_teste) 
{
  código a ser repetido;
}

OBS: O while (true) cria um loop que nunca termina por conta própria, ou seja, ele continuará rodando até que um comando de saída (como break) seja encontrado.
EX: 
int numero;
while (true)
{
    Console.WriteLine("Digite um número; número 15 encerra o loop");
    numero = int.Parse(Console.ReadLine());
    if (numero == 15)
    {
        break;
    }
    else
    {
        Console.WriteLine("Número digitado: {0}, ", numero);
    }                
}
Console.WriteLine("Esta mensagem aparece após o encerramento do loop");
_______________________________________________________________________________________________________________________________________________________________________
ESTRUTURA FOR ("Para"): Difere do while, onde no while você tem que ficar se preocupando dentro do próprio código com a escrita de uma instrução que eventualmente encerre o loop, para que não tenha loop infinito. No For, é mais fácil, pois em uma linha já é possível definir o inicio e o fim do loop, ou seja devem ser loops para os quais você já saiba de antemão quantas vezes ele vai rodar. Exemplo de uso do for: Quando trabalhamos com arrays ou matrizes. Nem sempre será possível utilizar o for, terá situações onde precisaremos ter maior interação maior com o usuário, nesses casos devemos usar o while ou o do.

Sintaxe:
for (inicialização; expressão; controle) 
{
  comandos a executar;
}
_______________________________________________________________________________________________________________________________________________________________________

ESTRUTURA DO WHILE ("Faça Enquanto"): Os loops while e for testam a expressão booleana no início do loop. No caso da declaração do a expressão booleana é avaliada APÓS cada iteração; desta forma o corpo do loop será executado ao menos uma vez. Então se queremos uma aplicação que execute um comando antes de fazer um teste lógico para verificar se ele vai continuar sendo executado, deve-se utilizar o do. 
 
Sintaxe:

do 
{
  bloco de comandos;
}
while (expressão de teste);
_______________________________________________________________________________________________________________________________________________________________________

DECLARAÇÃO BREAK: Utilizada para sair imediatamente do corpo de um loop. O break interrompe o loop completamente, o continue interrompe uma iteração do loop mas sem sair do programa

DECLARAÇÃO CONTINUE: Podemos uma declaração continue para que um loop seja interrompido e realize a próxima iteração imediatamente, ignorando os comandos que estão após a declaração continue. Ou seja, o loop vai executando os comandos do seu bloco de comandos e ao encontrar a declaração continue,  ele para a execução(ele não executa o restante do bloco), mas ele não sai do loop, ele volta pro inicio avalia novamente e expressão do loop e começa de novo a iterar o bloco. O continue interrompe uma iteração do loop mas sem sair do programa, o break interrompe o loop completamente.
_______________________________________________________________________________________________________________________________________________________________________

ARRAY: Um array ("vetor") é uma sequência não-ordenada de itens. Todos os itens em um array são do mesmo tipo. Os itens em um array são armazenados em um bloco contíguo da memória RAM e são acessados por meio de um número de índice.

Sintaxe:
tipo[] nome_array;

Exemplo: int[] numeros_loteria;

OBS: O tamanho do array não faz parte da declaração. Podemos criar array de qualquer tipo, tanto de valor quanto de referência.

_______________________________________________________________________________________________________________________________________________________________________
CRIAR UMA INSTÂNCIA O ARRAY: Os arrays são tipos de referência, independentemente do tio de seus elementos. Ou seja, uma variável array faz referência a um boco de memória que armazenará os elementos do array no heap.
Assim como com as variáveis de classes,  memória não é alocada para o array até que criemos uma instância dele usando o operador new. O array somente recebe espaço na memória a instância é criada -  e é quando especificamos o tamanho do array.

Como a memória para  a instância do array é alocada dinamicanete, o tamanho do array pode ser calculado em tempo de execução:

int tamanho = Int32.Parse(Console.ReadLine());
int[] valores = new int[tamanho];

_______________________________________________________________________________________________________________________________________________________________________
PREENCHENDO UM ARRAY: Podemos inicializar os elementos de um array fornecendo uma lista de elementos separados por vírgulas, entre chaves:
int[] numeros_loteria = new int[6] {2, 23,, 34, 12, 29, 44};

Podemos também usar essa sintaxe:
int[] numeros_loteria = {2, 23,, 34, 12, 29, 44};

Omitindo a palavra new - o compilador calcula o tamanho do array a partir da lista de elementos inicializadores e gera o código que cria o array.
_______________________________________________________________________________________________________________________________________________________________________

ITERAÇÃO PELOS ELEMENTOS DE UM ARRAY: Podemos consultar a propriedade Length para descobrir quantos elementos um array possui, e assim iterar por eles usando um laço for:
int[] meuaaray = {2,4,6,3,5,9};
for (int i = 0; i < meuarray.Length; i++)
{
  Console.WriteLine(meuarray[i]);
}
_______________________________________________________________________________________________________________________________________________________________________

ITERAÇAO COM FOREACH: Podemos iterar pelos elementos de um array para retornar seus elementos sem nos preocuparmos em determinar seu tamanho, usando a estrutura foreach:
int[] meuarray = {2,4,6,3,5,9};
foreh (int elemento in mearray)  // a variável iterativa (elemento) deve ser do mesmo tipo dos valores que estão dentro do array.
{
   Console.WriteLine(elemento);
}

OBS: Não é possível  modificar os elementos do array enquanto é feita iteração com foreach(usar for). Mas se a intenção for somente retornar todos os elementos do array na sequencia, utilize o foreach, ele sempre itera por todos os elementos do array, começando em 0 e indo até o final.
_______________________________________________________________________________________________________________________________________________________________________

COPIANDO ARRAYS: Para copiarmos os dados de um array, vamos proceder da seguinte forma: Criamos uma nova instância de array do mesmo tipo e mesmo tamanho do array original. Depois, copiamos os elementos um por um do original para o novo array:
int[] números = {4,7,3,8,0};
int[] copiaNumeros = new int[números.Length];
for (int i = 0; i < numeros.Length; i++)
{
  copiaNumeros[i] = numeros[i];
}

MÉTODO CopyTo: Neste exemplo, copiaremos os elementos do array números para o array copiaNumeros, iniciando no elemento zero:

int[] números = {4,7,3,8,0};
int[] copiaNumeros = new int[numeros.Length];
números.CopyTo(copiaNumeros, 0);  


Inicializamos o array de destino antes de chamar o método.

OBS: o método CopyTo não necessariamente vai copiar todos os elementos, ele pode copiar todos os elementos se você quiser, mas ele pode copiar os elementos a partir de uma determinada posição apenas. O que permite que você copie um pedaço de um array para um array menor caso você precise.


EX: COPIANDO A PARTIR DA POSIÇÃO 0.
números.CopyTo(copiaNumeros, 0); 
O zero indica a primeira posição pelo qual eu quero começar a copiar os valores do array(pode ser de qualquer outra posição existente).
_______________________________________________________________________________________________________________________________________________________________________

MÉTODOS: Um método é uma sequência de declarações (comandos) que possui um nome de identificação. É similar a uma função ou procedimento. Um método possui um nome e um corpo onde ficam os comandos que serão executados quando o método for chamado. Os métodos também podem receber dados para processamento (parâmetros) e retornar informações.

DECLARAÇÃO DE MÉTODOS
Sintaxe:
acesso tipo retorno nome método (parâmetros)
{
   corpo do método (variáveis e declarações)
}

OBS-1: Em programação existem as funções que são sequencias de comandos que retornam dados, e existem os procedimentos que são sequencias de comandos que executam uma ação ou uma tarefa (ex: escrever uma mensagem na tela). Já métodos fazem as duas coisas, ele pode agir tanto como se fosse uma função, quanto como se fosse um procedimento, a diferença vai estar na forma como você escreve o método.  

OBS-2: Caso você esteja escrevendo um método que não retornará um valor, use a palavra void no lugar de tipo_retorno. O método deve sempre executar uma operação única, se você estiver escrevendo um método que faz mais de uma tarefa, mais de um calculo por exemplo, você esta fazendo errado, provavelmente o que voce tem que fazer é criar 2 métodos, uma para cada tarefa/operação.

OBS-3: O VOID significa este método executa uma tarefa e não retorna dados para o chamador.

OBS-4: O tipo de acesso no método, tem a ver com a visibilidade que o método. A partir de onde eu posso acessar esse método.

OBS-5: Os parênteses dos métodos devem sempre deverão estar  no método mesmo que não haja argumento nenhum para ser passado.

OBS-6: Os parâmetros são variáveis ou dados que você passa para o método enquanto você esta escrevendo o método. Os argumentos são as variáveis ou dados que você passa para o método na hora que você chama o método, e os argumentos são mapeados para os parâmetros correspondentes.

OBS-7: Tipo de acesso Static, significa que não preciso criar uma instância da classe para usar esse método. Ex: static void Main(string[] args).

OBS-8: Para poder usar uma classe, você cria uma instância dela que nós chamados de objeto, e utiliza esse objeto dentro do programa.
Então se um classe possui métodos, para poder acessar os método dessa classe, você instancia a classe primeiro criando um objeto e ai você consegue acessar os métodos dentro do objeto. Se declararmos um método como static, você não precisa criar uma instância para trabalhar com ele.

OBS-9: Não deve-se criar um método dentro de outro método. Inclusive não deve-se criar um método dentro do método Main.


CHAMANDO MÉTODOS:
Sintaxe:
resutado = nome método(argumentos);

Se o método for void (não retorna valores), então a cláusula resultado = não será usada:
nome_método(argumentos);



